/******************************************************************************
   クラリオン殿向け                    2007  C3X03ｼﾘｰｽﾞ[仮]
		ﾌﾟﾛｼﾞｪｸﾄ名	: '07年ﾌﾘｯﾌﾟﾀﾞｳﾝ MP3ﾓﾃﾞﾙ開発
		ﾌｧｲﾙ名		: common.c
        ﾓｼﾞｭｰﾙ名	: COMM
		機能		: System共通 ﾗｲﾌﾞﾗﾘ
------------------------------------------------------------------------------
	修正履歴【年月日】【Ver】【名前】 【説明】
------------------------------------------------------------------------------
            2005.12.23  0.00   櫻田    新規作成
******************************************************************************/
#define		_COMMON_C_

#include	"common.h"

/******************************************************************************
	関   数  名	: Cm_wait_loop
	引       数	: ﾙｰﾌﾟｶｳﾝﾄ数
	戻   り  値	: なし
	機 能 概 略	: 指定されてｶｳﾝﾄ数分を0までｶｳﾝﾄする
    備       考 : 通信ﾀｲﾐﾝｸﾞを調整する時のWaitなどで使用。
------------------------------------------------------------------------------
	修正履歴【年月日】【Ver】【名前】 【説明】
[sun090309] 新規作成
******************************************************************************/
void Cm_wait_loop( BYTE cnt  )
{
	volatile BYTE loopcnt;
	
	for (loopcnt = cnt; loopcnt > 0; loopcnt--)
	{
		;
	}
}

/******************************************************************************
	関   数  名	: Cm_bcd_add_w
	引       数	: WORD  bcd1 ⇒ BCD 2byteﾃﾞｰﾀ
				: WORD  bcd2 ⇒ BCD 2byteﾃﾞｰﾀ
	戻   り  値	: WORD  足し算の結果
	機 能 概 略	: BDCﾃﾞｰﾀ(2byte)＋BDCﾃﾞｰﾀ(2byte)を計算
    備       考 : 戻り値が2byteを超えても2byteのみ返却
------------------------------------------------------------------------------
	修正履歴【年月日】【Ver】【名前】 【説明】
            2006.08.11  0.00   櫻田    新規作成
******************************************************************************/
WORD Cm_bcd_add_w( WORD bcd1, WORD bcd2  )
{
	WORD	hex1, hex2, ret  ;
	BYTE	bcd[3];

	hex1 = wBcd16ToHex16( bcd1 );
	hex2 = wBcd16ToHex16( bcd2 );
	hex1 += hex2;
	Cm_lib_wHEXtoBCD( hex1, bcd );

	ret = ( bcd[1] * 0x100 ) | bcd[2]  ;	/* WORDに変換 */

	return ret ;
}

/******************************************************************************
	関   数  名	: Cm_bcd_sub_w
	引       数	: WORD  bcd1 ⇒ BCD引かれる数
				: WORD  bcd2 ⇒ BCD引く数
	戻   り  値	: WORD  引き算の結果
	機 能 概 略	: bcd1 - bcd2 = ret
    備       考 :
------------------------------------------------------------------------------
	修正履歴【年月日】【Ver】【名前】 【説明】
            2006.08.11  0.00   櫻田    新規作成
            2006.09.09		 sakurada	正しく返せないので、マイナス値にならないように修正。
******************************************************************************/
WORD Cm_bcd_sub_w( WORD bcd1, WORD bcd2  )
{
	WORD	hex1, hex2, ret  ;
	BYTE	bcd[3];

	if( bcd1 < bcd2 )
	{
		return 0x0000;
	}

	hex1 = wBcd16ToHex16( bcd1 );
	hex2 = wBcd16ToHex16( bcd2 );
	hex1 -= hex2;
	Cm_lib_wHEXtoBCD( hex1, bcd );

	ret = ( bcd[1] * 0x100 ) | bcd[2]  ;	/* WORDに変換 */

	return ret ;
}


/******************************************************************************
	関   数  名	: Cm_lib_wHEXtoBCD
	引       数	: WORD  hex ⇒ HEXﾃﾞｰﾀ（4桁）
				: BYTE* bcd ⇒ BCDﾃﾞｰﾀ格納用ﾎﾟｲﾝﾀ
	戻   り  値	: 処理結果  ⇒ OK/NG
	機 能 概 略	: HEXﾃﾞｰﾀ(2byte)を BCDﾃﾞｰﾀへ変換
    備       考 : 戻り値用のRAMは３byte分確保してからコールしてください。
------------------------------------------------------------------------------
	修正履歴【年月日】【Ver】【名前】 【説明】
            2005.12.01  0.00   櫻田    新規作成
			[sun051226]上位桁から入れるように変更
            2006.04.10  0.00   櫻田    HEXﾃﾞｰﾀが０でもそのまま変換するよう修正
            2006.04.18  0.00   櫻田    0番地もありうるので、ｴﾗｰを返さないようにする。
******************************************************************************/
BYTE Cm_lib_wHEXtoBCD( WORD hex, BYTE * bcd  )
{
	BYTE m,s,x,y,z ;


	m = (BYTE)( hex / 10000);											/* 万の位 */
	s = (BYTE)((hex - (10000 * m))  / 1000);								/* 千の位 */
	x = (BYTE)((hex - (10000 * m) - (1000 * s)) / 100);					/* 百の位 */
	y = (BYTE)((hex - (10000 * m) - (1000 * s) - (100 * x)) / 10);		/* 十の位 */
	z = (BYTE)( hex - (10000 * m) - (1000 * s) - (100 * x) - (10 * y));	/* 一の位 */

	/* 戻り値格納 */
	*bcd     = m ;
	*(++bcd) = (s << 4) + x ;
	*(++bcd) = (y << 4) + z ;

	return OK ;
}

/******************************************************************************
	関   数  名	: Cm_lib_bHEXtoBCD
	引       数	: BYTE  hex ⇒ HEXﾃﾞｰﾀ
	戻   り  値	: WORD  bcd ⇒ BCDﾃﾞｰﾀ
	機 能 概 略	: HEXﾃﾞｰﾀ(1byte)を BCDﾃﾞｰﾀへ変換
    備       考 :
------------------------------------------------------------------------------
	修正履歴【年月日】【Ver】【名前】 【説明】
            2005.12.01  0.00   櫻田    新規作成
            2006.04.16  0.01   櫻田    戻り値をWORDで返すように修正
******************************************************************************/
WORD Cm_lib_bHEXtoBCD( BYTE hex )
{
	BYTE y,z;
	WORD bcd,x;

	x = (WORD)( hex / 100);							/* 百の位 */
	y = (BYTE)((hex - (100 * x)) / 10);				/* 十の位 */
	z = (BYTE)( hex - (100 * x) - (10 * y));		/* 一の位 */

	bcd = (WORD)((x << 8) + (y << 4) + z);						/* HEX ⇒ BCD */

	return bcd ;
}

/*-----------------------------------------------------------------------------
	関 数 名	: Utf8encode_Iso8859
	引    数	: *str: source
				  *buff: target
				  len: source len
	戻 り 値	: result: 変換後長さ
	機 能 概 略	: Iso8859 → UTF8
	コ メ ン ト : ソースlen <=512（暫定）、
				  目標バッファ >len*2（推奨）
-------------------------------------------------------------------------------
	修正履歴
	[shen20100806]新規作成
	[shen20100824]NULL文字チェックし見つけたら戻る
	[shen20100824]XML専用文字変換追加
-------------------------------------------------------------------------------*/
WORD Utf8encode_Iso8859( BYTE *str, BYTE *buff, WORD len )
{
	WORD result;
	BYTE moji;

	result = 0;
	if(( len > 0 ) && ( len <= 512 ))
	{
		/* UTF8ドキュメントマーク */
		#if 0	/* ドキュメント用 */
		buff[0] = 0xEF;
		buff[1] = 0xBB;
		buff[2] = 0xBF;
		buff += 3;
		result += 3;
		#endif
		
		/* 変換処理 */
		while( len > 0 )
		{
			moji = *str;
			if( moji == 0x00 )		/* NULL文字チェック */
			{
				break;
			}
			else if(( moji & 0x80 ) == 0x80 )
			{
				buff[1] = 0x80 | ( moji & 0x3F );
				buff[0] = 0xC0 | (( moji >> 6 ) & 0x03);
				buff += 2;
				result += 2;
			}
			else
			{
				#if 0			/* [sun100830]特殊文字必要か不明、とりあえずｺﾒﾝﾄ */
				/* XML格式専用 */
				if( moji == '&' )		/* & → &amp; */
				{
					wMemCopy( "&amp;", buff, 5);
					buff += 5;
					result += 5;
				}
				else if( moji == '<' )		/* < → &lt; */
				{
					wMemCopy( "&lt;", buff, 4);
					buff += 4;
					result += 4;
				}
				else if( moji == '>' )		/* > → &gt; */
				{
					wMemCopy( "&gt;", buff, 4);
					buff += 4;
					result += 4;
				}
				else
				#endif
				{
					buff[0] = moji;
					buff += 1;
					result += 1;
				}
			}
			str++;
			len--;
		}
	}
	return result;
}

/*-----------------------------------------------------------------------------
	関 数 名	: Base64encode
	引    数	: *str: source
				  *buff: target
				  len: source len
	戻 り 値	: result: 変換後長さ
	機 能 概 略	: ISO8859 → Base64
	コ メ ン ト : ソースlen <=512（暫定）、
				  目標バッファ >len*4/3+2（推奨）
-------------------------------------------------------------------------------
	修正履歴
	[shen20100806]新規作成
-------------------------------------------------------------------------------*/
static BYTE const base64EncodeChars[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; 

WORD Base64encode( BYTE *str, BYTE *buff, WORD len )
{
	BYTE c1, c2, c3;
	WORD i = 0;
	WORD result = 0;
	
	while(i < len)
	{
		c1 = str[i++];
		if(i == len)
		{
			buff[result++] = base64EncodeChars[c1 >> 2];
			buff[result++] = base64EncodeChars[(c1 & 0x03) << 4];
			buff[result++] = '=';
			buff[result++] = '=';
			break;
		}

		c2 = str[i++];
		if(i == len)
		{
			buff[result++] = base64EncodeChars[c1 >> 2];
			buff[result++] = base64EncodeChars[((c1 & 0x03) << 4 ) | ((c2 & 0xF0) >> 4)];
			buff[result++] = base64EncodeChars[(c2 & 0x0F) << 2];
			buff[result++] = '=';
			break;
		}

		c3 = str[i++];
		buff[result++] = base64EncodeChars[c1 >> 2];
		buff[result++] = base64EncodeChars[((c1 & 0x03) << 4 ) | ((c2 & 0xF0) >> 4)];
		buff[result++] = base64EncodeChars[((c2 & 0x0F) << 2 ) | ((c3 & 0xC0) >> 6)];
		buff[result++] = base64EncodeChars[c3 & 0x3F];
	}
	
	return result;
}

/****************************************************************
		関数名：romcopy
		引  数：buf→ｺﾋﾟｰ先のRAMﾊﾞｯﾌｧのﾎﾟｲﾝﾀ
				radd→ｺﾋﾟｰ元のROMﾃｰﾌﾞﾙﾎﾟｲﾝﾀ
				size→ｺﾋﾟｰｻｲｽﾞ
		戻り値：無し
		機  能：ROMﾃｰﾌﾞﾙｺﾋﾟｰ
		備  考：サイズMAX256
----------------------------------------------------------------
修正履歴	【年月日】【Version】【名前】 【説明】
----------------------------------------------------------------
			2006/4/1		0.1		徐		新規作成
****************************************************************/
void romcopy(BYTE *buf, BYTE *radd, BYTE size)
{
	BYTE cnt;
	BYTE *src;

	src = (BYTE *)radd;

	for(cnt = 0; cnt < size; buf++,src++,cnt++)
	{
		*buf = *src;
	}
}
/****************************************************************
		関数名：romcmp
		引  数：buf→RAMﾎﾟｲﾝﾀ
				radd→ROMﾎﾟｲﾝﾀ
				size→比較ｻｲｽﾞ
		戻り値：FALSE→data一致
				TRUE→data不一致
		機  能：RAM/ROMのﾃﾞｰﾀ比較する
		備  考：サイズMAX256
----------------------------------------------------------------
修正履歴	【年月日】【Version】【名前】 【説明】
----------------------------------------------------------------
			2006/4/1		0.1		徐		新規作成
****************************************************************/
BOOL romcmp(BYTE *buf, BYTE *radd, BYTE size)
{
	BYTE cnt,compare;
	BYTE *src;

	src = (BYTE *)radd;
	compare = FALSE;			/* 初期値→一致 */
	cnt = 0;
	while(cnt < size)
	{
		if(*buf != *src)
		{
			compare = TRUE;
		}
		buf++;
		src++;
		cnt++;
	}
	return(compare);
}
/**********************************************************************************************************************
	関　数　名	: wBcd16ToHex16
	引　　　数	: USHORT型		ＢＣＤデータ（ 0x0000 - 0x9999 )
	戻　り　値	: USHORT型		ＨＥＸデータ（ 0x0000 - 0x270f )
	機　能　概　略	:0x0000 - 0x9999  のＢＣＤデータを 0x0000 - 0x270f のＨＥＸコードに変換する
-------------------------------------------------------------------------------
	修正履歴
	番号	日付　　　担当者		修正内容
  【000】	06/3/14	　YouKin	    06モデル流用
**********************************************************************************************************************/
static WORD const aBcdToHexWordDataTable[]=
{
	0,
	100,
	200,
	300,
	400,
	500,
	600,
	700,
	800,
	900,
	1000,
	1100,
	1200,
	1300,
	1400,
	1500
};
static WORD const aBcdToHexByteDataTable[]=
{
	  0,	/*	 0xh	*/
	 10,	/*	 1xh	*/
	 20,	/*	 2xh	*/
	 30,	/*	 3xh	*/
	 40,	/*	 4xh	*/
	 50,	/*	 5xh	*/
	 60,	/*	 6xh	*/
	 70,	/*	 7xh	*/
	 80,	/*	 8xh	*/
	 90,	/*	 9xh	*/
	100,	/*	 Axh	*/
	110,	/*	 Bxh	*/
	120,	/*	 Cxh	*/
	130,	/*	 Dxh	*/
	140,	/*	 Exh	*/
	150,	/*	 Fxh	*/
};

WORD wBcd16ToHex16( WORD bcd )
{
	register BYTE cWork;
	register WORD wWork;

	wWork = aBcdToHexWordDataTable[ bcd/0x100 ];
	cWork = aBcdToHexByteDataTable[ ((BYTE)bcd) / 0x10];
	wWork = wWork + (((BYTE)cWork)&0x0ff);
	cWork = ((BYTE)bcd) % 0x10;
	wWork = wWork + (((BYTE)cWork)&0x0ff);
	return wWork;
}

/***************************************************************************
 関　数　名 : wMemClear
 引　　　数 : ｐｓ クリアするアドレス
      ｃｎｔ クリア数
 戻　り　値 : なし
 機　能　概　略 :*ps から cnt 分の領域を 0 クリアします
----------------------------------------------------------------------------
 修正履歴
 番号 日付　　　担当者  修正内容
  【000】 06/3/14 　YouKin     06モデル流用
****************************************************************************/
void wMemClear( BYTE* ps, WORD cnt )
{
	for( ; cnt > 0 ; cnt-- )
	{
		*ps = 0;
		ps++;
	}
}

/***************************************************************************
 関　数　名 : wMemCopy
 引　　　数 : ｐｓ 転送元アドレス
      ｐｄ 転送先アドレス
      ｃｎｔ 転送数
 戻　り　値 : なし
 機　能　概　略 :*ps を *pd へ、１バイト単位で、cnt 分を転送します。
----------------------------------------------------------------------------
 修正履歴
 番号 日付　　　担当者  修正内容
  【000】 06/3/14 　YouKin     06モデル流用
****************************************************************************/
void wMemCopy( BYTE *ps, BYTE *pd, WORD cnt )
{
	register WORD iCnt;
	for( iCnt = 0 ; iCnt < cnt ; iCnt++ )
	{
		*pd = *ps;
		pd ++;
		ps ++;
	}
}

/***************************************************************************
 関　数　名 : wMemSet
 引　　　数 : ps   充填するアドレス
      val   充填値
       cnt   領域数（2byte）
 戻　り　値 : なし
 機　能　概　略 :*ps から Cnt分の領域を 充填値val で埋める
----------------------------------------------------------------------------
 修正履歴
 番号 日付　　　担当者  修正内容
  【000】 06/3/14 　YouKin     06モデル流用
****************************************************************************/
void wMemSet( BYTE *ps , BYTE val, WORD cnt )
{
	for( ; cnt > 0 ; cnt-- )
	{
		*ps = val;
		ps++;
	}
}

/***************************************************************************
 関　数　名 : wMemCmp
 引　　　数 : ps   アドレス
      		  pd   アドレス
              cnt   領域数（2byte）
 戻　り　値 : 異なる場合、真を返す
 機　能　概　略 :*ps と *pd の領域比較を行う
----------------------------------------------------------------------------
 修正履歴
 番号 日付　　　担当者  修正内容
  【000】 06/3/14 　YouKin     06モデル流用
****************************************************************************/
BOOL wMemCmp( BYTE* ps, BYTE* pd, WORD cnt )
{
	register WORD Loop;
	for( Loop = 0 ; Loop < cnt ; Loop++ )
	{
		if( *ps != *pd )
		{
			break;
		}
		ps++;
		pd++;
	}
 	return ((cnt == 0)||( Loop != cnt ));
}


#undef  _COMMON_C_


